### 起因：常规设计图尺寸：1920 x 1080 ，缩放100%，部分台式机、笔记本电脑分辨率不一致，并自带系统缩放，如：

#### （1）笔记本：1920 x 1200， 缩放125%

#### （2）台式机2k：2560 x 1440，缩放125%

#### （3）笔记本：2880 x 1800，缩放200%

#### 1. 调整方案一： Zoom适配(不推荐)

```typescript
// 在App.vue的 onMounted 生命周期里引入并执行即可。
function bodyScale() {
  const deviceWidth = document.documentElement.clientWidth;

  // 设计稿尺寸
  const designWidth = 1920;

  const scale = deviceWidth / designWidth;

  document.body.style.zoom = String(scale); // 放大缩小相应倍数

  // document.body.style.zoom = 1 / window.devicePixelRatio; // 此处 devicePixelRatio 为系统本身的缩放百分比，如125%
}
```

#### 效果：通过各种兼容适配后，基本可用，但潜在风险过大，还是会引起部分未测出来的bug。

#### 缺陷：非浏览器规范标准属性，不支持所有版本的火狐浏览器，且每次元素改动时都会发生重排，性能风险过高。带有el-popper这个class的悬浮框组件（如el-select、tooltip、pagination的页码选择）基本都会出现错位；echarts的悬浮指示器会出现错位。

#### 1）其中el-select可以通过全局设置 ``ElementUI.Select.props.popperAppendToBody.default = false``解决

#### tooltip可以通过引入以下代码解决

```javascript
// element-ui-bug-fixed.js
import Popper from 'element-ui/lib/utils/popper'
Popper.prototype.modifiers.applyStyle = function (data) {
	// console.log(data.placement);
	// apply the final offsets to the popper
	// NOTE: 1 DOM access here
	var styles = {
		position: data.offsets.popper.position,
		direction: data.placement
	}
	// round top and left to avoid blurry text
	var left = Math.round(data.offsets.popper.left)
	var top = Math.round(data.offsets.popper.top)

	// if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper
	// we automatically use the supported prefixed version if needed
	var prefixedProperty
	if (
		this._options.gpuAcceleration &&
		(prefixedProperty = getSupportedPropertyName('transform'))
	) {
		styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)'
		styles.top = 0
		styles.left = 0
	}
	// othwerise, we use the standard `left` and `top` properties
	else {
		//获取当前zoom
		var zoom = window?.$wujie?.props?.bodyZoom || window.getComputedStyle(document.body).zoom
		// var zoom = 1.06667
		styles.left = left
		styles.top = top
		//当有zoom值时，重新修改样式
		if (zoom !== '1') {
			//其中top-start和top是popper打开的方向，可以通过打印styles.direction来判断这个组件的打开方向
			if (styles.direction === 'top-start') {
				styles.left = left / zoom
				styles.top = top / zoom
			} else if (styles.direction === 'top') {
				styles.left = left / zoom
				styles.top = top / zoom
			} else {
				styles.left = left / zoom
				styles.top = top / zoom
			}
		} else {
			styles.left = left
			styles.top = top
		}
	}

	// any property present in `data.styles` will be applied to the popper,
	// in this way we can make the 3rd party modifiers add custom styles to it
	// Be aware, modifiers could override the properties defined in the previous
	// lines of this modifier!
	Object.assign(styles, data.styles)

	setStyle(this._popper, styles)

	// set an attribute which will be useful to style the tooltip (use it to properly position its arrow)
	// NOTE: 1 DOM access here
	this._popper.setAttribute('x-placement', data.placement)

	// if the arrow modifier is required and the arrow style has been computed, apply the arrow style
	if (
		this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) &&
		data.offsets.arrow
	) {
		setStyle(data.arrowElement, data.offsets.arrow)
	}

	return data
}
function setStyle (element, styles) {
	function is_numeric (n) {
		return n !== '' && !isNaN(parseFloat(n)) && isFinite(n)
	}
	Object.keys(styles).forEach(function (prop) {
		var unit = ''
		// add unit if the value is numeric and is one of the following
		if (
			['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !==
			-1 &&
			is_numeric(styles[prop])
		) {
			unit = 'px'
		}
		element.style[prop] = styles[prop] + unit
	})
}
```

#### 2）el-pagination里的页码选择el-select未暴露接口，可以考虑根据PR重写再全局覆盖。

#### 3）echarts修复：

```javascript
// echarts-zoom-fixed.js
//解决zoom放大缩小导致echarts位置偏移问题
const scale = window?.$wujie?.props?.bodyZoom || '1'
let strScale = `scale(${scale})`;
var obj = {
    zoom: 1 / scale,
    transform: strScale,
    transformOrigin: "0 0",
};

insertCss("canvas", obj);
function insertCss(select, styles) {
    console.log(styles);
    if (document.styleSheets.length === 0) {
        //如果没有style标签,则创建一个style标签
        var style = document.createElement("style");
        document.head.appendChild(style);
    }
    var styleSheet = document.styleSheets[document.styleSheets.length - 1]; //如果有style 标签.则插入到最后一个style标签中
    var str = select + " {"; //插入的内容必须是字符串,所以得把obj转化为字符串
    for (var prop in styles) {
        str +=
            prop.replace(/([A-Z])/g, function (item) {
                //使用正则把大写字母替换成 '-小写字母'
                return "-" + item.toLowerCase();
            }) +
            ":" +
            styles[prop] +
            ";";
    }
    str += "}";
    styleSheet.insertRule(str, styleSheet.cssRules.length); //插入样式到最后一个style标签中的最后面
}
```

#### 3）相关issue：[Zoom相关Issue](https://github.com/ElemeFE/element/issues?q=is%3Aissue%20state%3Aopen%20zoom)，

#### 4）相关PR: [Pagination: el-select in el-pagination supports popperAppendToBody #22948](https://github.com/ElemeFE/element/pull/22948)

#### 5）相关参考：

[浏览器缩放后 element ui组件偏移](https://blog.csdn.net/qq_35556763/article/details/147306747?spm=1001.2014.3001.5502)
[Vue3 解决电脑分辨率及缩放导致页面变形的问题](https://blog.csdn.net/Tsinbo1314/article/details/121860895)

#### 2. 调整方案二：CSS3 scale属性适配（Cursor Claude 4.0生成，未采用）

```typescript
// 在App.vue的 onMounted 生命周期里引入并执行即可。
function bodyScale() {
  var devicewidth = document.documentElement.clientWidth;
  var deviceheight = document.documentElement.clientHeight;

  // 设计稿尺寸
  var designWidth = 1920;
  var designHeight = 1080; // 假设设计稿高度为1080，您可以根据实际情况调整

  var scaleX = devicewidth / designWidth;
  var scaleY = deviceheight / designHeight;

  // 使用较小的缩放比例，确保内容完全适配
  var scale = Math.min(scaleX, scaleY);

  document.body.style.transform = `scale(${String(scale)})`; //放大缩小相应倍数
  document.body.style.transformOrigin = "center";
  document.body.style.width = `${100 / scale}%`;
  document.body.style.height = `${100 / scale}%`;
}
```

#### 效果：可用，按比例重新调整缩放，每次变更元素只会触发重绘，整体适合大屏方案。

#### 缺陷：在部分分辨率下（1920x1200缩放125%和2560x1440缩放150%和175%）两侧会出现白边，且无法通过调整浏览器缩放清除白边。

### 最终方案：考虑到整体技术体系为wujie微前端，调整外层父应用菜单的适配性似乎更好，外层body的zoom和scale都会不同程度影响到内层子应用。考虑尝试rem方案调整字体适配度。